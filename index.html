<!DOCTYPE html>
<html lang="en">
<meta charset="utf-8">
<title>profiler get symbols wasm test page</title>

<body>

  <style>
    body {
      margin: 50px 200px;
    }

    .mainSection>section {
      margin: 40px 0;
      border-radius: 5px;
      box-shadow: 0 5px 8px rgb(0, 0, 0, 0.3);
      border: 1px solid rgb(180, 180, 180);
      padding: 10px 20px;
    }

    .mainSection>section>section {
      margin: 20px 0;
      border-radius: 5px;
      box-shadow: 0 5px 8px rgb(0, 0, 0, 0.3);
      padding: 0 10px;
      border: 1px solid rgb(180, 180, 180);
    }

    textarea {
      white-space: pre;
    }
  </style>

  <script src="profiler_get_symbols_wasm.js"></script>

  <section class="mainSection">

  </section>

  <section class="initiaterButtons">
    <p>
      <input type="button" value="Start Symbol Table Query" onclick="startSymbolTableQuery()">
      <input type="button" value="Start API Query" onclick="startAPIQuery()">
    </p>
  </section>

  <script>

    const mainSection = document.querySelector(".mainSection");

    const { CompactSymbolTable, WasmMemBuffer, getCompactSymbolTable, queryAPI } = wasm_bindgen;

    const request = new Request('./profiler_get_symbols_wasm_bg.wasm', {
      // Optional: Add integrity check here.
      // Obtain the sha384 of profiler_get_symbols_wasm_bg.wasm as follows:
      // $ shasum -b -a 384 profiler_get_symbols_wasm_bg.wasm | awk '{ print $1 }' | xxd -r -p | base64
      // Then uncomment the following line, with the hash substituted:
      //
      // integrity: 'sha384-yourhashhere'
    });

    WebAssembly.compileStreaming(fetch(request)).then(module => {
      return wasm_bindgen(module);
    }).catch(error => {
      console.error(error);
    });

    function getFileResultOrUndefined(fileInput) {
      return new Promise((resolve, reject) => {
        if (!fileInput.files[0]) {
          resolve();
          return;
        }
        const fileReader = new FileReader();
        fileReader.readAsArrayBuffer(fileInput.files[0]);
        fileReader.onload = function () {
          resolve(fileReader.result);
        };
        fileReader.onerror = function () {
          resolve();
        };
      }).catch(() => { });
    }

    async function queryInputForSymbolTable(parentElement) {
      const section = document.createElement("section");
      section.innerHTML = `
        <h3>Query Input</h3>
        <p>debugName: <input type="text" class="debugName" size="40" value="firefox.pdb"></p>
        <p>breakpadID: <input type="text" class="breakpadId" size="40" value="AA152DEB2D9B76084C4C44205044422E2"></p>
        <p><input type="button" class="begin" value="Begin"> <input type="button" class="cancel" value="Cancel"></p>`;
      parentElement.appendChild(section);
      document.scrollingElement.scrollTo(0, 100000);
      const debugNameInput = section.querySelector(".debugName");
      const breakpadIdInput = section.querySelector(".breakpadId");
      const beginButton = section.querySelector(".begin");
      const cancelButton = section.querySelector(".cancel");

      try {
        return await new Promise((resolve, reject) => {
          beginButton.onclick = () => {
            const debugName = debugNameInput.value;
            const breakpadId = breakpadIdInput.value;
            resolve({ debugName, breakpadId });
          };
          cancelButton.onclick = () => {
            reject(new Error("Cancel button clicked"));
          };
        });
      } finally {
        debugNameInput.disabled = true;
        breakpadIdInput.disabled = true;
        beginButton.disabled = true;
        cancelButton.disabled = true;
      }
    }

    async function queryInputForAPI(parentElement) {
      const section = document.createElement("section");
      section.innerHTML = `
        <h3>Query Input</h3>
        <p>URL: <input type="text" class="url" size="40" value="/symbolicate/v6a1"></p>
        <p>requestJSON: <textarea class="requestJSON" rows="20" cols="80"></textarea></p>
        <p><input type="button" class="begin" value="Begin"> <input type="button" class="cancel" value="Cancel"></p>`;
      parentElement.appendChild(section);
      document.scrollingElement.scrollTo(0, 100000);
      const urlInput = section.querySelector(".url");
      const requestJSONInput = section.querySelector(".requestJSON");
      const beginButton = section.querySelector(".begin");
      const cancelButton = section.querySelector(".cancel");
      requestJSONInput.value = `{
  "memoryMap": [
    [
      "firefox.pdb",
      "AA152DEB2D9B76084C4C44205044422E2"
    ],
    [
      "mozglue.pdb",
      "63C609072D3499F64C4C44205044422E2"
    ]
  ],
  "stacks": [
    [
      [0,204776],
      [0,129423],
      [0,244290],
      [0,244219],
      [1,244290],
      [1,244219],
      [1, 237799]
    ]
  ]
}`
      // requestJSONInput.value = '{"jobs": [{"stacks":[[[0,247618],[0,685896],[0,686768]]],"memoryMap":[["libmozglue.so","0CE47B7C29F27CED55C41233B93EBA450"]]}]}';
      try {
        return await new Promise((resolve, reject) => {
          beginButton.onclick = () => {
            const url = urlInput.value;
            const requestJSON = requestJSONInput.value;
            resolve({ url, requestJSON });
          };
          cancelButton.onclick = () => {
            reject(new Error("Cancel button clicked"));
          };
        });
      } finally {
        urlInput.disabled = true;
        requestJSONInput.disabled = true;
        beginButton.disabled = true;
        cancelButton.disabled = true;
      }
    }

    function printError(error, parentElement) {
      const section = document.createElement("section");
      section.innerHTML = `
        <h3>Exception Fired</h3>
        <p><textarea class="exceptionText" readonly cols="100" rows="4"></textarea></p>`;
      parentElement.appendChild(section);
      document.scrollingElement.scrollTo(0, 100000);
      const exceptionTextTextarea = section.querySelector(".exceptionText");
      const { name, message } = error;
      exceptionTextTextarea.value = JSON.stringify({ name, message, ...error });
    }

    function addGetCandidatePathsForBinaryOrPdbSection(parentElement, debugName, breakpadId, res) {
      const section = document.createElement("section");
      section.innerHTML = `
        <h3><code>getCandidatePathsForBinaryOrPdb</code> called</h3>
        <p><textarea class="values" readonly cols="100" rows="2"></textarea></p>`;
      parentElement.appendChild(section);
      document.scrollingElement.scrollTo(0, 100000);
      const valuesTextarea = section.querySelector(".values");
      valuesTextarea.value = `debugName: ${debugName}, breakpadId: ${breakpadId}
returning ${JSON.stringify(res)}`;
    }

    async function getFileFromUser(filename, parentElement) {
      const section = document.createElement("section");
      section.innerHTML = `
        <h3><code>readFile</code> called</h3>
        <p>Please pick the following file: <code class="filename"></code></p>
        <p><input type="file" class="fileInput"> <input type="button" class="ok" value="OK"> <input type="button" class="cancel" value="Cancel"></p>`;
      parentElement.appendChild(section);
      document.scrollingElement.scrollTo(0, 100000);
      const filenameCode = section.querySelector(".filename");
      const fileInput = section.querySelector(".fileInput");
      const okButton = section.querySelector(".ok");
      const cancelButton = section.querySelector(".cancel");

      filenameCode.textContent = filename;

      try {
        await new Promise((resolve, reject) => {
          okButton.onclick = () => resolve();
          cancelButton.onclick = () => {
            reject(new Error("Cancel button clicked"));
          };
        });
      } finally {
        fileInput.disabled = true;
        okButton.disabled = true;
        cancelButton.disabled = true;
      }
      const arrayBufferOrUndefined = getFileResultOrUndefined(fileInput);
      if (arrayBufferOrUndefined === undefined) {
        throw new Error("Didn't get file result");
      }
      return arrayBufferOrUndefined;
    }

    function printSymbolTableOutput(output, parentElement) {
      const section = document.createElement("section");
      section.innerHTML = `
        <h3>Success!</h3>
        <p>Result from symbol table query:</p>
        <p><textarea class="output" readonly cols="100" rows="25"></textarea></p>`;
      parentElement.appendChild(section);
      document.scrollingElement.scrollTo(0, 100000);
      const outputTextarea = section.querySelector(".output");

      const [addr, index, buffer] = output;
      let text = `Received symbol table with ${addr.length} symbols:\n\n`;
      text += symbolTableToTextList([addr, index, buffer]);
      outputTextarea.value = text;
    }

    function printAPIOutput(output, parentElement) {
      const section = document.createElement("section");
      section.innerHTML = `
        <h3>Success!</h3>
        <p>Result from symbol table query:</p>
        <p><textarea class="output" readonly cols="100" rows="25"></textarea></p>`;
      parentElement.appendChild(section);
      document.scrollingElement.scrollTo(0, 100000);
      const outputTextarea = section.querySelector(".output");
      try {
        // Pretty-print JSON.
        outputTextarea.value = JSON.stringify(JSON.parse(output), null, 4);
      } catch (e) {
        outputTextarea.value = output;
      }
    }

    class Helper {
      constructor(parentElement) {
        this._element = parentElement;
      }

      async getCandidatePathsForBinaryOrPdb(debugName, breakpadId) {
        const res = [debugName];
        addGetCandidatePathsForBinaryOrPdbSection(this._element, debugName, breakpadId, res);
        return res;
      }

      async readFile(filename) {
        const arrayBuffer = await getFileFromUser(filename, this._element);
        const buffer = new WasmMemBuffer(arrayBuffer.byteLength, array => {
          array.set(new Uint8Array(arrayBuffer));
        });
        return {
          getBuffer: () => buffer
        };
      }
    }

    async function startSymbolTableQuery() {
      const symbolTableQuerySection = document.createElement("section");
      symbolTableQuerySection.innerHTML = `
        <h2>Symbol Table Query</h2>`;
      mainSection.appendChild(symbolTableQuerySection);
      document.scrollingElement.scrollTo(0, 100000);
      const helper = new Helper(symbolTableQuerySection);
      try {
        const { debugName, breakpadId } = await queryInputForSymbolTable(symbolTableQuerySection);
        const output = await getCompactSymbolTable(debugName, breakpadId, helper);
        printSymbolTableOutput(output, symbolTableQuerySection);
      } catch (e) {
        printError(e, symbolTableQuerySection);
      }
    }

    async function startAPIQuery() {
      const apiQuerySection = document.createElement("section");
      apiQuerySection.innerHTML = `
        <h2>Symbol API Query</h2>`;
      mainSection.appendChild(apiQuerySection);
      document.scrollingElement.scrollTo(0, 100000);
      const helper = new Helper(apiQuerySection);
      try {
        const { url, requestJSON } = await queryInputForAPI(apiQuerySection);
        const output = await queryAPI(url, requestJSON, helper);
        printAPIOutput(output, apiQuerySection);
      } catch (e) {
        printError(e, apiQuerySection);
      }
    }

    function symbolTableToSymbolMapObj([addr, index, buffer]) {
      const textDecoder = new TextDecoder();
      const mapObj = {};
      for (let i = 0; i < addr.length; i++) {
        mapObj[`0x${addr[i].toString(16)}`] = textDecoder.decode(buffer.subarray(index[i], index[i + 1]));
      }
      return mapObj;
    }

    function symbolTableToTextList([addr, index, buffer]) {
      const textDecoder = new TextDecoder();
      let text = "";
      for (let i = 0; i < addr.length; i++) {
        text += addr[i].toString(16) + ' ' + textDecoder.decode(buffer.subarray(index[i], index[i + 1])) + '\n';
      }
      return text;
    }

  </script>